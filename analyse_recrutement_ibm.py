#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Script d'analyse des donn√©es de recrutement IBM
Auteur: Assistant IA
Date: 2024
Description: Analyse compl√®te des donn√©es de candidatures, co√ªts, entretiens et postes
"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
from datetime import datetime
import warnings
warnings.filterwarnings('ignore')

# Configuration pour l'affichage en fran√ßais
plt.rcParams['font.size'] = 10
plt.rcParams['axes.unicode_minus'] = False

def charger_donnees():
    """
    Charge les 4 fichiers CSV dans des DataFrames pandas
    """
    print("=" * 60)
    print("CHARGEMENT DES DONN√âES")
    print("=" * 60)
    
    try:
        # Chargement des fichiers CSV
        candidatures = pd.read_csv('Candidatures.CSV')
        couts = pd.read_csv('couts.CSV')
        entretiens = pd.read_csv('Entretiens.CSV')
        postes = pd.read_csv('postes.CSV')
        
        print("‚úÖ Tous les fichiers ont √©t√© charg√©s avec succ√®s!")
        print(f"üìä Candidatures: {len(candidatures)} lignes")
        print(f"üí∞ Co√ªts: {len(couts)} lignes")
        print(f"üéØ Entretiens: {len(entretiens)} lignes")
        print(f"üíº Postes: {len(postes)} lignes")
        
        return candidatures, couts, entretiens, postes
    
    except FileNotFoundError as e:
        print(f"‚ùå Erreur: Fichier non trouv√© - {e}")
        return None, None, None, None
    except Exception as e:
        print(f"‚ùå Erreur lors du chargement: {e}")
        return None, None, None, None

def afficher_premieres_lignes(candidatures, couts, entretiens, postes):
    """
    Affiche les premi√®res lignes de chaque DataFrame
    """
    print("\n" + "=" * 60)
    print("APER√áU DES DONN√âES")
    print("=" * 60)
    
    print("\nüìã CANDIDATURES (5 premi√®res lignes):")
    print(candidatures.head())
    
    print("\nüí∞ CO√õTS (5 premi√®res lignes):")
    print(couts.head())
    
    print("\nüéØ ENTRETIENS (5 premi√®res lignes):")
    print(entretiens.head())
    
    print("\nüíº POSTES (5 premi√®res lignes):")
    print(postes.head())

def statistiques_descriptives(candidatures, couts, entretiens, postes):
    """
    Affiche les statistiques descriptives pour chaque DataFrame
    """
    print("\n" + "=" * 60)
    print("STATISTIQUES DESCRIPTIVES")
    print("=" * 60)
    
    print("\nüìä CANDIDATURES - Statistiques num√©riques:")
    print(candidatures.describe())
    
    print("\nüí∞ CO√õTS - Statistiques num√©riques:")
    print(couts.describe())
    
    print("\nüéØ ENTRETIENS - Statistiques num√©riques:")
    print(entretiens.describe())
    
    print("\nüíº POSTES - Statistiques num√©riques:")
    print(postes.describe())

def analyses_avancees(candidatures, couts, entretiens, postes):
    """
    Effectue des analyses avanc√©es sur les donn√©es
    """
    print("\n" + "=" * 60)
    print("ANALYSES AVANC√âES")
    print("=" * 60)
    
    # 1. Corr√©lation entre cv_score et notes d'entretien
    print("\n1Ô∏è‚É£ CORR√âLATION CV_SCORE vs NOTES D'ENTRETIEN")
    print("-" * 40)
    
    # Fusion des donn√©es candidatures et entretiens
    candidatures_entretiens = candidatures.merge(entretiens, on='id_candidature', how='inner')
    
    # Calcul de la note moyenne par candidature
    notes_moyennes = candidatures_entretiens.groupby('id_candidature')['note_sur_10'].mean().reset_index()
    candidatures_avec_notes = candidatures.merge(notes_moyennes, on='id_candidature', how='inner')
    
    correlation = candidatures_avec_notes['cv_score'].corr(candidatures_avec_notes['note_sur_10'])
    print(f"Corr√©lation entre cv_score et note moyenne d'entretien: {correlation:.3f}")
    
    if correlation > 0.7:
        print("‚úÖ Forte corr√©lation positive - Les CV scores pr√©disent bien les performances en entretien")
    elif correlation > 0.3:
        print("‚úÖ Corr√©lation mod√©r√©e positive")
    elif correlation > -0.3:
        print("‚ö†Ô∏è Corr√©lation faible")
    else:
        print("‚ùå Corr√©lation n√©gative")
    
    # 2. Analyse des co√ªts par canal de recrutement
    print("\n2Ô∏è‚É£ ANALYSE DES CO√õTS PAR CANAL DE RECRUTEMENT")
    print("-" * 40)
    
    candidatures_couts = candidatures.merge(couts, on='id_candidature', how='inner')
    couts_par_canal = candidatures_couts.groupby('canal_recrutement')['cout_total'].agg(['mean', 'sum', 'count']).round(2)
    couts_par_canal.columns = ['Co√ªt moyen', 'Co√ªt total', 'Nombre de candidatures']
    print(couts_par_canal.sort_values('Co√ªt moyen', ascending=False))
    
    # 3. Taux de conversion par d√©partement
    print("\n3Ô∏è‚É£ TAUX DE CONVERSION PAR D√âPARTEMENT")
    print("-" * 40)
    
    candidatures_postes = candidatures.merge(postes, on='id_poste', how='inner')
    
    # Calcul du taux de conversion (Embauch√© / Total candidatures)
    conversion_par_dept = candidatures_postes.groupby('departement').agg({
        'id_candidature': 'count',
        'statut_actuel': lambda x: (x == 'Embauch√©').sum()
    }).rename(columns={'id_candidature': 'Total_candidatures', 'statut_actuel': 'Embauch√©s'})
    
    conversion_par_dept['Taux_conversion'] = (conversion_par_dept['Embauch√©s'] / conversion_par_dept['Total_candidatures'] * 100).round(2)
    print(conversion_par_dept.sort_values('Taux_conversion', ascending=False))
    
    # 4. Dur√©e moyenne des entretiens par type
    print("\n4Ô∏è‚É£ DUR√âE MOYENNE DES ENTRETIENS PAR TYPE")
    print("-" * 40)
    
    duree_par_type = entretiens.groupby('type_entretien')['duree_minutes'].agg(['mean', 'count']).round(2)
    duree_par_type.columns = ['Dur√©e moyenne (min)', 'Nombre d\'entretiens']
    print(duree_par_type.sort_values('Dur√©e moyenne (min)', ascending=False))

def creer_graphiques(candidatures, couts, entretiens, postes):
    """
    Cr√©e les 4 graphiques demand√©s
    """
    print("\n" + "=" * 60)
    print("CR√âATION DES GRAPHIQUES")
    print("=" * 60)
    
    # Configuration du style des graphiques
    plt.style.use('default')
    sns.set_palette("husl")
    
    # Cr√©ation d'une figure avec 2x2 sous-graphiques
    fig, axes = plt.subplots(2, 2, figsize=(15, 12))
    fig.suptitle('Analyse des Donn√©es de Recrutement IBM', fontsize=16, fontweight='bold')
    
    # 1. Histogramme des cv_scores
    print("üìä Cr√©ation de l'histogramme des cv_scores...")
    axes[0, 0].hist(candidatures['cv_score'], bins=15, alpha=0.7, color='skyblue', edgecolor='black')
    axes[0, 0].set_title('Distribution des CV Scores', fontweight='bold')
    axes[0, 0].set_xlabel('CV Score')
    axes[0, 0].set_ylabel('Fr√©quence')
    axes[0, 0].grid(True, alpha=0.3)
    
    # Ajout de la moyenne
    moyenne_cv = candidatures['cv_score'].mean()
    axes[0, 0].axvline(moyenne_cv, color='red', linestyle='--', label=f'Moyenne: {moyenne_cv:.1f}')
    axes[0, 0].legend()
    
    # 2. Box plot des co√ªts par statut
    print("üí∞ Cr√©ation du box plot des co√ªts par statut...")
    candidatures_couts = candidatures.merge(couts, on='id_candidature', how='inner')
    
    # Filtrer les statuts avec suffisamment de donn√©es
    statuts_avec_couts = candidatures_couts.groupby('statut_actuel').filter(lambda x: len(x) >= 3)
    
    if len(statuts_avec_couts) > 0:
        sns.boxplot(data=statuts_avec_couts, x='statut_actuel', y='cout_total', ax=axes[0, 1])
        axes[0, 1].set_title('Distribution des Co√ªts par Statut', fontweight='bold')
        axes[0, 1].set_xlabel('Statut Actuel')
        axes[0, 1].set_ylabel('Co√ªt Total (‚Ç¨)')
        axes[0, 1].tick_params(axis='x', rotation=45)
    else:
        axes[0, 1].text(0.5, 0.5, 'Donn√©es insuffisantes\npour le box plot', 
                       ha='center', va='center', transform=axes[0, 1].transAxes)
        axes[0, 1].set_title('Distribution des Co√ªts par Statut', fontweight='bold')
    
    # 3. Scatter plot cv_score vs note d'entretien
    print("üéØ Cr√©ation du scatter plot cv_score vs note d'entretien...")
    
    # Calcul de la note moyenne par candidature
    notes_moyennes = entretiens.groupby('id_candidature')['note_sur_10'].mean().reset_index()
    candidatures_avec_notes = candidatures.merge(notes_moyennes, on='id_candidature', how='inner')
    
    axes[1, 0].scatter(candidatures_avec_notes['cv_score'], candidatures_avec_notes['note_sur_10'], 
                      alpha=0.6, color='green')
    axes[1, 0].set_title('CV Score vs Note d\'Entretien', fontweight='bold')
    axes[1, 0].set_xlabel('CV Score')
    axes[1, 0].set_ylabel('Note Moyenne d\'Entretien')
    axes[1, 0].grid(True, alpha=0.3)
    
    # Ajout de la ligne de r√©gression
    correlation = candidatures_avec_notes['cv_score'].corr(candidatures_avec_notes['note_sur_10'])
    z = np.polyfit(candidatures_avec_notes['cv_score'], candidatures_avec_notes['note_sur_10'], 1)
    p = np.poly1d(z)
    axes[1, 0].plot(candidatures_avec_notes['cv_score'], p(candidatures_avec_notes['cv_score']), 
                    "r--", alpha=0.8, label=f'R√©gression (r={correlation:.2f})')
    axes[1, 0].legend()
    
    # 4. Bar chart des candidatures par canal
    print("üìà Cr√©ation du bar chart des candidatures par canal...")
    
    candidatures_par_canal = candidatures['canal_recrutement'].value_counts()
    
    bars = axes[1, 1].bar(candidatures_par_canal.index, candidatures_par_canal.values, 
                         color=sns.color_palette("husl", len(candidatures_par_canal)))
    axes[1, 1].set_title('Candidatures par Canal de Recrutement', fontweight='bold')
    axes[1, 1].set_xlabel('Canal de Recrutement')
    axes[1, 1].set_ylabel('Nombre de Candidatures')
    axes[1, 1].tick_params(axis='x', rotation=45)
    
    # Ajout des valeurs sur les barres
    for bar in bars:
        height = bar.get_height()
        axes[1, 1].text(bar.get_x() + bar.get_width()/2., height + 0.5,
                       f'{int(height)}', ha='center', va='bottom')
    
    # Ajustement de la mise en page
    plt.tight_layout()
    
    # Sauvegarde du graphique
    plt.savefig('analyse_recrutement_ibm.png', dpi=300, bbox_inches='tight')
    print("‚úÖ Graphiques sauvegard√©s dans 'analyse_recrutement_ibm.png'")
    
    # Affichage du graphique
    plt.show()

def resume_analyse(candidatures, couts, entretiens, postes):
    """
    Affiche un r√©sum√© de l'analyse
    """
    print("\n" + "=" * 60)
    print("R√âSUM√â DE L'ANALYSE")
    print("=" * 60)
    
    # Statistiques g√©n√©rales
    total_candidatures = len(candidatures)
    total_embauches = len(candidatures[candidatures['statut_actuel'] == 'Embauch√©'])
    taux_embauche_global = (total_embauches / total_candidatures * 100)
    
    print(f"\nüìä STATISTIQUES G√âN√âRALES:")
    print(f"   ‚Ä¢ Total candidatures: {total_candidatures}")
    print(f"   ‚Ä¢ Total embauches: {total_embauches}")
    print(f"   ‚Ä¢ Taux d'embauche global: {taux_embauche_global:.1f}%")
    
    # Canal le plus efficace
    candidatures_par_canal = candidatures.groupby('canal_recrutement').agg({
        'id_candidature': 'count',
        'statut_actuel': lambda x: (x == 'Embauch√©').sum()
    })
    candidatures_par_canal['taux_embauche'] = (candidatures_par_canal['statut_actuel'] / candidatures_par_canal['id_candidature'] * 100)
    canal_plus_efficace = candidatures_par_canal['taux_embauche'].idxmax()
    taux_canal_efficace = candidatures_par_canal['taux_embauche'].max()
    
    print(f"\nüéØ CANAL LE PLUS EFFICACE:")
    print(f"   ‚Ä¢ {canal_plus_efficace}: {taux_canal_efficace:.1f}% d'embauche")
    
    # D√©partement avec le plus de candidatures
    candidatures_postes = candidatures.merge(postes, on='id_poste', how='inner')
    dept_plus_candidatures = candidatures_postes['departement'].value_counts().index[0]
    nb_candidatures_dept = candidatures_postes['departement'].value_counts().iloc[0]
    
    print(f"\nüíº D√âPARTEMENT LE PLUS POPULAIRE:")
    print(f"   ‚Ä¢ {dept_plus_candidatures}: {nb_candidatures_dept} candidatures")
    
    # CV score moyen
    cv_score_moyen = candidatures['cv_score'].mean()
    print(f"\nüìù CV SCORE MOYEN:")
    print(f"   ‚Ä¢ {cv_score_moyen:.1f}/100")
    
    # Co√ªt moyen par embauche
    candidatures_couts = candidatures.merge(couts, on='id_candidature', how='inner')
    embauches_couts = candidatures_couts[candidatures_couts['statut_actuel'] == 'Embauch√©']
    cout_moyen_embauche = embauches_couts['cout_total'].mean()
    
    print(f"\nüí∞ CO√õT MOYEN PAR EMBAUCHE:")
    print(f"   ‚Ä¢ {cout_moyen_embauche:.0f}‚Ç¨")

def main():
    """
    Fonction principale qui orchestre toute l'analyse
    """
    print("üöÄ D√âBUT DE L'ANALYSE DES DONN√âES DE RECRUTEMENT IBM")
    print("=" * 60)
    
    # 1. Chargement des donn√©es
    candidatures, couts, entretiens, postes = charger_donnees()
    
    if candidatures is None:
        print("‚ùå Impossible de continuer sans les donn√©es")
        return
    
    # 2. Affichage des premi√®res lignes
    afficher_premieres_lignes(candidatures, couts, entretiens, postes)
    
    # 3. Statistiques descriptives
    statistiques_descriptives(candidatures, couts, entretiens, postes)
    
    # 4. Analyses avanc√©es
    analyses_avancees(candidatures, couts, entretiens, postes)
    
    # 5. Cr√©ation des graphiques
    creer_graphiques(candidatures, couts, entretiens, postes)
    
    # 6. R√©sum√© de l'analyse
    resume_analyse(candidatures, couts, entretiens, postes)
    
    print("\n" + "=" * 60)
    print("‚úÖ ANALYSE TERMIN√âE AVEC SUCC√àS!")
    print("=" * 60)
    print("üìÅ Fichiers g√©n√©r√©s:")
    print("   ‚Ä¢ analyse_recrutement_ibm.png (graphiques)")
    print("\nüìä Points cl√©s de l'analyse:")
    print("   ‚Ä¢ Tous les graphiques ont √©t√© cr√©√©s")
    print("   ‚Ä¢ Les analyses avanc√©es ont √©t√© effectu√©es")
    print("   ‚Ä¢ Le r√©sum√© complet est disponible ci-dessus")

if __name__ == "__main__":
    main() 